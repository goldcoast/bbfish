Index 1 Rendering performance 101:
[start:
So you’ve built the next great mobile app, but users are complaining that the experience isn’t always consistent, they’re calling it slow and hitchy. And they say that it does not scroll as smooth as they like. My name is Colt MoAnlis, and it sounds like your app has a serious rendering performance problem. But do not worry, we can fix it by looking at how Android is working under the hood.
Rendering performance is the most common performance issue that you run into while building an app. On the one hand, your designers want to produce the most usable, transcendent experience for your users, but on the other hand, all those fancy graphics and transitions may not work well on every device. So let’s take a look at what rendering performance is all about, firstly, knowing the whole system is attempt to redraw your activity every 16 milliseconds or so, which means that your application needs to run all of the logic the update the screen in that 16-millisecond frame in order to hit 60 frames per second. If you miss that window—let’s say  you take 24 milliseconds—you start to get what we call a dropped frame. The system tried to draw a new picture on the screen, but one wasn’t ready yet. so I did not reflush anything. The user ends up seeing the same graphic for 32 milliseconds rather than for 16. This effect of missed frames is at the core of what a user would call a laggy or janky experience. Any info that are going on during a dropped frame will see a jump in their smoothness, which user can easily see. It gets worse when this effect happens while the user are interacting with the system –for example, dragging a listview or typing in some data, this is what users quickly start to complain about. Now the is a whole group of reason could miss your 16 –milliseconds frame window. For example you may spend too much time on redrawing large parts of your view hierarchy, which wastes CPU cycles or you might be drawing too many objects on top of each other, which wastes valuable time coloring in pixels that aren’t visible to the final user. Or you could be doing a ton of animation over and over and over again, which can cause large amounts of churn on both your CPU and GPU components. Detecting and fixing these problems is highly dependent on how your app is built. But generally, it comes down to using the available tools to track down and identify what’s going wrong. For example, you can use hierarchy viewer to understand if your activity is too complex, which can lead to issues with spending too much time invalidating or wasting time redrawing.you can also use the on-device tools, like profile GPU rendering, show GPU overdraw, and GPU view updtes, to get a better sense of where in your application you’re running into problems. And for the tricky rendering bugs that manifest themselves in CPU code, Traceview is a great tool to track down what’s causing a missed 16-millisecond frame.
Rendering performance is one of the easiest performance problems to fall into, but don’t let that stop you from making an amaze app. Check the rest of android performance patterns resources, and don’t forget to join our Google+ community. So keep calm, profile your code, and always remember, perf matters~.

END]